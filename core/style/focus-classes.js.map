{"version":3,"file":"focus-classes.js","sourceRoot":"","sources":["../../../../../src/lib/core/style/focus-classes.ts"],"names":[],"mappings":"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","sourcesContent":["import {Directive, Injectable, Optional, SkipSelf, Renderer, ElementRef} from '@angular/core';\r\nimport {Observable} from 'rxjs/Observable';\r\nimport {Subject} from 'rxjs/Subject';\r\n\r\n\r\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\r\n// that a value of around 650ms seems appropriate.\r\nexport const TOUCH_BUFFER_MS = 650;\r\n\r\n\r\nexport type FocusOrigin = 'touch' | 'mouse' | 'keyboard' | 'program';\r\n\r\n\r\n/** Monitors mouse and keyboard events to determine the cause of focus events. */\r\n@Injectable()\r\nexport class FocusOriginMonitor {\r\n  /** The focus origin that the next focus event is a result of. */\r\n  private _origin: FocusOrigin = null;\r\n\r\n  /** The FocusOrigin of the last focus event tracked by the FocusOriginMonitor. */\r\n  private _lastFocusOrigin: FocusOrigin;\r\n\r\n  /** Whether the window has just been focused. */\r\n  private _windowFocused = false;\r\n\r\n  /** The target of the last touch event. */\r\n  private _lastTouchTarget: EventTarget;\r\n\r\n  /** The timeout id of the touch timeout, used to cancel timeout later. */\r\n  private _touchTimeout: number;\r\n\r\n  constructor() {\r\n    // Note: we listen to events in the capture phase so we can detect them even if the user stops\r\n    // propagation.\r\n\r\n    // On keydown record the origin and clear any touch event that may be in progress.\r\n    document.addEventListener('keydown', () => {\r\n      this._lastTouchTarget = null;\r\n      this._setOriginForCurrentEventQueue('keyboard');\r\n    }, true);\r\n\r\n    // On mousedown record the origin only if there is not touch target, since a mousedown can\r\n    // happen as a result of a touch event.\r\n    document.addEventListener('mousedown', () => {\r\n      if (!this._lastTouchTarget) {\r\n        this._setOriginForCurrentEventQueue('mouse');\r\n      }\r\n    }, true);\r\n\r\n    // When the touchstart event fires the focus event is not yet in the event queue. This means we\r\n    // can't rely on the trick used above (setting timeout of 0ms). Instead we wait 650ms to see if\r\n    // a focus happens.\r\n    document.addEventListener('touchstart', (event: Event) => {\r\n      if (this._touchTimeout != null) {\r\n        clearTimeout(this._touchTimeout);\r\n      }\r\n      this._lastTouchTarget = event.target;\r\n      this._touchTimeout = setTimeout(() => this._lastTouchTarget = null, TOUCH_BUFFER_MS);\r\n    }, true);\r\n\r\n    // Make a note of when the window regains focus, so we can restore the origin info for the\r\n    // focused element.\r\n    window.addEventListener('focus', () => {\r\n      this._windowFocused = true;\r\n      setTimeout(() => this._windowFocused = false, 0);\r\n    });\r\n  }\r\n\r\n  /** Register an element to receive focus classes. */\r\n  registerElementForFocusClasses(element: Element, renderer: Renderer): Observable<FocusOrigin> {\r\n    let subject = new Subject<FocusOrigin>();\r\n    renderer.listen(element, 'focus',\r\n        (event: Event) => this._onFocus(event, element, renderer, subject));\r\n    renderer.listen(element, 'blur', () => this._onBlur(element, renderer, subject));\r\n    return subject.asObservable();\r\n  }\r\n\r\n  /** Focuses the element via the specified focus origin. */\r\n  focusVia(element: Node, renderer: Renderer, origin: FocusOrigin) {\r\n    this._setOriginForCurrentEventQueue(origin);\r\n    renderer.invokeElementMethod(element, 'focus');\r\n  }\r\n\r\n  /** Sets the origin and schedules an async function to clear it at the end of the event queue. */\r\n  private _setOriginForCurrentEventQueue(origin: FocusOrigin) {\r\n    this._origin = origin;\r\n    setTimeout(() => this._origin = null, 0);\r\n  }\r\n\r\n  /** Checks whether the given focus event was caused by a touchstart event. */\r\n  private _wasCausedByTouch(event: Event): boolean {\r\n    // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\r\n    // Consider the following dom structure:\r\n    //\r\n    // <div #parent tabindex=\"0\" cdkFocusClasses>\r\n    //   <div #child (click)=\"#parent.focus()\"></div>\r\n    // </div>\r\n    //\r\n    // If the user touches the #child element and the #parent is programmatically focused as a\r\n    // result, this code will still consider it to have been caused by the touch event and will\r\n    // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\r\n    // relatively small edge-case that can be worked around by using\r\n    // focusVia(parentEl, renderer,  'program') to focus the parent element.\r\n    //\r\n    // If we decide that we absolutely must handle this case correctly, we can do so by listening\r\n    // for the first focus event after the touchstart, and then the first blur event after that\r\n    // focus event. When that blur event fires we know that whatever follows is not a result of the\r\n    // touchstart.\r\n    let focusTarget = event.target;\r\n    return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\r\n        (focusTarget == this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\r\n  }\r\n\r\n  /** Handles focus events on a registered element. */\r\n  private _onFocus(event: Event, element: Element, renderer: Renderer,\r\n                   subject: Subject<FocusOrigin>) {\r\n    // If we couldn't detect a cause for the focus event, it's due to one of two reasons:\r\n    // 1) The window has just regained focus, in which case we want to restore the focused state of\r\n    //    the element from before the window blurred.\r\n    // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\r\n    // 3) The element was programmatically focused, in which case we should mark the origin as\r\n    //    'program'.\r\n    if (!this._origin) {\r\n      if (this._windowFocused && this._lastFocusOrigin) {\r\n        this._origin = this._lastFocusOrigin;\r\n      } else if (this._wasCausedByTouch(event)) {\r\n        this._origin = 'touch';\r\n      } else {\r\n        this._origin = 'program';\r\n      }\r\n    }\r\n\r\n    renderer.setElementClass(element, 'cdk-focused', true);\r\n    renderer.setElementClass(element, 'cdk-touch-focused', this._origin == 'touch');\r\n    renderer.setElementClass(element, 'cdk-keyboard-focused', this._origin == 'keyboard');\r\n    renderer.setElementClass(element, 'cdk-mouse-focused', this._origin == 'mouse');\r\n    renderer.setElementClass(element, 'cdk-program-focused', this._origin == 'program');\r\n    subject.next(this._origin);\r\n\r\n    this._lastFocusOrigin = this._origin;\r\n    this._origin = null;\r\n  }\r\n\r\n  /** Handles blur events on a registered element. */\r\n  private _onBlur(element: Element, renderer: Renderer, subject: Subject<FocusOrigin>) {\r\n    renderer.setElementClass(element, 'cdk-focused', false);\r\n    renderer.setElementClass(element, 'cdk-touch-focused', false);\r\n    renderer.setElementClass(element, 'cdk-keyboard-focused', false);\r\n    renderer.setElementClass(element, 'cdk-mouse-focused', false);\r\n    renderer.setElementClass(element, 'cdk-program-focused', false);\r\n    subject.next(null);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Directive that determines how a particular element was focused (via keyboard, mouse, or\r\n * programmatically) and adds corresponding classes to the element.\r\n */\r\n@Directive({\r\n  selector: '[cdkFocusClasses]',\r\n})\r\nexport class CdkFocusClasses {\r\n  changes: Observable<FocusOrigin>;\r\n\r\n  constructor(elementRef: ElementRef, focusOriginMonitor: FocusOriginMonitor, renderer: Renderer) {\r\n    this.changes =\r\n        focusOriginMonitor.registerElementForFocusClasses(elementRef.nativeElement, renderer);\r\n  }\r\n}\r\n\r\n\r\nexport function FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY(parentDispatcher: FocusOriginMonitor) {\r\n  return parentDispatcher || new FocusOriginMonitor();\r\n}\r\n\r\n\r\nexport const FOCUS_ORIGIN_MONITOR_PROVIDER = {\r\n  // If there is already a FocusOriginMonitor available, use that. Otherwise, provide a new one.\r\n  provide: FocusOriginMonitor,\r\n  deps: [[new Optional(), new SkipSelf(), FocusOriginMonitor]],\r\n  useFactory: FOCUS_ORIGIN_MONITOR_PROVIDER_FACTORY\r\n};\r\n"]}